def python_numerical_audit(dimension_data):
    """
    Python å·¥ç¨‹å¼•æ“ (v73: å«è¦æ ¼ç¼ºæ¼æª¢æŸ¥)
    æ–°å¢åŠŸèƒ½ï¼š
    - è‹¥æœ‰é …ç›®åç¨± (item_title)ï¼Œä½†è¦æ ¼ (std_spec) ç‚ºç©ºï¼Œç›´æ¥å ±éŒ¯ã€‚
    """
    grouped_errors = {}
    import re
    
    if not dimension_data: return []

    for item in dimension_data:
        # 1. åŸºç¤è®Šæ•¸æå–
        page_num = item.get("page", "?")
        raw_title = str(item.get("item_title", ""))
        title = raw_title.replace(" ", "").replace('"', "").strip()
        
        # å–å¾—ä¸¦æ¸…æ´—è¦æ ¼
        raw_spec = str(item.get("std_spec", "")).strip()
        if raw_spec.lower() in ['nan', 'none', 'null']: raw_spec = ""

        # ========================================================
        # ğŸ”¥ [æ–°å¢åŠŸèƒ½] è¦æ ¼ç¼ºæ¼æª¢æŸ¥ (Missing Spec Check)
        # ========================================================
        # æ¢ä»¶ï¼šæœ‰æ¨™é¡Œ(titleå­˜åœ¨) ä¸” æ²’è¦æ ¼(raw_specç‚ºç©º)
        # æ’é™¤ï¼šå¦‚æœæ¨™é¡Œæœ¬èº«å°±æ˜¯ç©ºçš„ï¼Œæˆ–è€…åŒ…å«å¸¸è¦‹é›œè¨Š(å¦‚ "å‚™è¨»")å‰‡ä¸æŠ“
        if title and not raw_spec and len(title) > 1:
            # å»ºç«‹éŒ¯èª¤å¡ç‰‡
            key = (page_num, raw_title, "è¦æ ¼ç¼ºæ¼")
            if key not in grouped_errors:
                grouped_errors[key] = {
                    "page": page_num, 
                    "item": raw_title, 
                    "issue_type": "âš ï¸è¦æ ¼ç¼ºæ¼", 
                    "common_reason": "æœ‰é …ç›®åç¨±ï¼Œä½†æœªåµæ¸¬åˆ°è¦æ ¼æ•¸æ“š", 
                    "failures": [{"id": "è¦æ ¼æ¬„", "val": "ç©ºç™½", "calc": "ç¼ºå¤±"}],
                    "source": "ğŸ å·¥ç¨‹å¼•æ“"
                }
            # æ—¢ç„¶æ²’è¦æ ¼ï¼Œå¾Œé¢çš„æ•¸å€¼æ¯”å°ä¹Ÿä¸ç”¨åšäº†ï¼Œç›´æ¥è·³ä¸‹ä¸€é¡Œ
            continue 
        # ========================================================

        # 2. æª¢æŸ¥æ˜¯å¦æœ‰æ•¸æ“š (å¦‚æœé€£æ•¸æ“šéƒ½æ²’æœ‰ï¼Œé€šå¸¸æ˜¯ç©ºè¡Œï¼Œè·³é)
        ds = str(item.get("ds", ""))
        if not ds: continue
        
        raw_entries = [p.split(":") for p in ds.split("|") if ":" in p]
        
        # 3. è®€å–åˆ†é¡èˆ‡é‚è¼¯ (ä»¥ä¸‹ç¶­æŒåŸæœ‰åŠ›å­¸)
        cat = str(item.get("category", "")).strip()
        logic = item.get("sl", {})
        l_type = logic.get("lt", "") 
        
        # è±å…æª¢æŸ¥
        t_upper = title.upper()
        if any(k in t_upper for k in ["å‹•å¹³è¡¡", "BALANCING", "ç†±è™•ç†", "HEAT"]):
            continue
            
        if "SKIP" in str(l_type).upper() or "EXEMPT" in str(l_type).upper() or "è±å…" in str(l_type):
            continue

        # --- ä»¥ä¸‹ç‚ºåŸæœ¬çš„æ•¸å€¼æå–èˆ‡æª¢æŸ¥é‚è¼¯ (ä¿æŒä¸è®Š) ---
        
        mm_nums = [float(n) for n in re.findall(r"(\d+\.?\d*)\s*mm", raw_spec)]
        all_nums = [float(n) for n in re.findall(r"(\d+\.?\d*)", raw_spec)]
        noise = [350.0, 300.0, 200.0, 145.0, 130.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
        clean_std = [n for n in all_nums if (n in mm_nums) or (n not in noise and n > 5)]

        s_ranges = []
        spec_parts = re.split(r"[\n\r]|[ä¸€äºŒä¸‰å››äº”å…­]|[ï¼ˆ(]\d+[)ï¼‰]|[;ï¼›]", raw_spec)
        
        for part in spec_parts:
            part = part.replace("+-", "Â±").replace("ï¼‹ï¼", "Â±")
            
            if "Â±" in part:
                left_str, right_str = part.split("Â±", 1)
                left_str = left_str.replace(" ", "")
                right_str = right_str.replace(" ", "")
                left_nums = re.findall(r"(\d+\.?\d*)", left_str)
                right_nums = re.findall(r"(\d+\.?\d*)", right_str)
                
                if left_nums and right_nums:
                    b = float(left_nums[-1]) 
                    o = float(right_nums[0])
                    s_ranges.append([round(b - o, 4), round(b + o, 4)])
                    continue 
            
            clean_part = part.replace("mm", "_").replace("MM", "_").replace(" ", "").replace("\n", "").strip()
            if not clean_part: continue
            
            tilde_matches = list(re.finditer(r"(\d+\.?\d*)\s*[_]*\s*[~ï½-]\s*[_]*\s*(\d+\.?\d*)", clean_part))
            has_valid_tilde = False
            if tilde_matches:
                for match in tilde_matches:
                    n1 = float(match.group(1))
                    n2 = float(match.group(2))
                    if abs(n1 - n2) < max(n1, n2) * 0.6:
                        s_ranges.append([round(min(n1, n2), 4), round(max(n1, n2), 4)])
                        has_valid_tilde = True
            if has_valid_tilde: continue

            all_numbers = re.findall(r"[-+]?\d+\.?\d*", clean_part)
            if not all_numbers: continue
            try:
                bases = []
                offsets = []
                for token in all_numbers:
                    val = float(token)
                    if val > 10.0: bases.append(val)
                    elif abs(val) < 10.0: offsets.append(val)
                if bases:
                    for b in bases:
                        if offsets:
                            endpoints = [round(b + o, 4) for o in offsets]
                            if len(endpoints) == 1: endpoints.append(b)
                            s_ranges.append([min(endpoints), max(endpoints)])
                        else:
                            s_ranges.append([b, b])
            except: continue
                    
        if l_type in ["range", "max_limit", "min_limit"]:
            un_regen_target = None
        else:
            s_threshold = logic.get("t", 0)
            un_regen_target = None
            if l_type in ["un_regen", "æœªå†ç”Ÿ"] or ("æœªå†ç”Ÿ" in (cat + title) and not any(k in (cat + title) for k in ["è»¸é ¸", "è»¸é ­", "è»¸ä½"])):
                cands = [n for n in clean_std if n >= 120.0]
                if s_threshold and float(s_threshold) >= 120.0: cands.append(float(s_threshold))
                if cands: un_regen_target = max(cands)

        for entry in raw_entries:
            if len(entry) < 2: continue
            rid = str(entry[0]).strip().replace(" ", "")
            val_raw = str(entry[1]).strip().replace(" ", "")
            
            if not val_raw or val_raw in ["N/A", "nan", "M10"]: continue

            try:
                is_passed, reason, t_used, engine_label = True, "", "N/A", "æœªçŸ¥"

                if "[!]" in val_raw:
                    is_passed = False
                    reason = "ğŸ›‘æ•¸æ“šæå£(å£è»Œ)"
                    val_str = "[!]"
                    val = -999.0 
                else:
                    v_m = re.findall(r"\d+\.?\d*", val_raw)
                    val_str = v_m[0] if v_m else val_raw
                    val = float(val_str)

                if val_str != "[!]":
                    is_two_dec = "." in val_str and len(val_str.split(".")[-1]) == 2
                    is_pure_int = "." not in val_str
                else:
                    is_two_dec, is_pure_int = True, True 

                if "min_limit" in str(l_type) or "éŠ²è£œ" in (cat + title):
                    engine_label = "éŠ²è£œ"
                    if not is_pure_int: is_passed, reason = False, "æ‡‰ç‚ºç´”æ•´æ•¸"
                    elif clean_std:
                        t_used = min(clean_std, key=lambda x: abs(x - val))
                        if val < t_used: is_passed, reason = False, "æ•¸å€¼ä¸è¶³"
                
                elif un_regen_target is not None:
                    engine_label = "æœªå†ç”Ÿ"
                    t_used = un_regen_target
                    if val <= t_used:
                        if not is_pure_int: is_passed, reason = False, "æ‡‰ç‚ºæ•´æ•¸"
                    elif not is_two_dec: 
                        is_passed, reason = False, "æ‡‰å¡«å…©ä½å°æ•¸"

                elif str(l_type) == "max_limit" or (any(k in (cat + title) for k in ["è»¸é ¸", "è»¸é ­", "è»¸ä½"]) and ("æœªå†ç”Ÿ" in (cat + title))):
                    engine_label = "è»¸é ¸(ä¸Šé™)"
                    candidates = clean_std
                    target = max(candidates) if candidates else 0
                    t_used = target
                    if target > 0:
                        if not is_pure_int: is_passed, reason = False, "æ‡‰ç‚ºç´”æ•´æ•¸"
                        elif val > target: is_passed, reason = False, f"è¶…éä¸Šé™ {target}"

                elif str(l_type) == "range" or (any(x in (cat + title) for x in ["å†ç”Ÿ", "ç²¾åŠ å·¥", "ç ”ç£¨", "è»Šä¿®", "çµ„è£", "æ‹†è£", "çœŸåœ“åº¦"]) and "æœªå†ç”Ÿ" not in (cat + title)):
                    engine_label = "ç²¾åŠ å·¥"
                    if not is_two_dec:
                        is_passed, reason = False, "æ‡‰å¡«å…©ä½å°æ•¸"
                    elif s_ranges:
                        t_used = str(s_ranges)
                        if not any(r[0] <= val <= r[1] for r in s_ranges): 
                            is_passed, reason = False, "ä¸åœ¨å€é–“å…§"

                if not is_passed:
                    key = (page_num, raw_title, reason)
                    if key not in grouped_errors:
                        grouped_errors[key] = {
                            "page": page_num, "item": raw_title, 
                            "issue_type": f"ç•°å¸¸({engine_label})", 
                            "common_reason": reason, "failures": [],
                            "source": "ğŸ å·¥ç¨‹å¼•æ“"
                        }
                    grouped_errors[key]["failures"].append({"id": rid, "val": val_str, "target": f"åŸºæº–:{t_used}"})
                    
            except: continue
                
    return list(grouped_errors.values())
